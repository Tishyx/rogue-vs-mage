<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D PvP Duel: Rogue vs Frost Mage</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
        }

        .health-bar-container {
            position: absolute;
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }

        #playerHealth {
            top: 20px;
            left: 20px;
        }

        #enemyHealth {
            top: 20px;
            right: 20px;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(to bottom, #4caf50, #2e7d32);
            transition: width 0.3s ease;
            position: relative;
        }

        .mana-bar {
            height: 100%;
            background: linear-gradient(to bottom, #2196f3, #1565c0);
            transition: width 0.3s ease;
        }

        .resource-bar-container {
            position: absolute;
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }

        #playerEnergy {
            top: 55px;
            left: 20px;
        }

        #comboPoints {
            position: absolute;
            top: 80px;
            left: 20px;
            display: flex;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.65);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
            transition: transform 0.25s ease;
        }

        #comboPoints.combo-change {
            transform: scale(1.08);
        }

        .combo-point {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 215, 0, 0.8);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 6px rgba(255, 215, 0, 0.25);
            transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }

        .combo-point.active {
            background: radial-gradient(circle at center, #ffd54f 0%, #ffa000 80%);
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.8);
            transform: scale(1.1);
        }

        #enemyMana {
            top: 55px;
            right: 20px;
        }

        #enemyCastBar {
            position: absolute;
            top: 85px;
            right: 20px;
            width: 300px;
            height: 24px;
            background: rgba(0, 0, 0, 0.75);
            border: 2px solid #163b63;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
            visibility: hidden;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        #enemyCastBar.active {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }

        #enemyCastBar .cast-progress {
            height: 100%;
            width: 0;
            background: linear-gradient(to right, #7dd0ff, #2a7edc);
            transition: width 0.05s linear;
        }

        #enemyCastBar .cast-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #f5f9ff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        #enemyCastBar.interrupted .cast-progress {
            background: linear-gradient(to right, #ff7a7a, #d32f2f);
        }

        #enemyCastBar.interrupted .cast-text {
            color: #ffdede;
        }

        .energy-bar {
            height: 100%;
            background: linear-gradient(to bottom, #ffeb3b, #f57c00);
            transition: width 0.3s ease;
        }

        .bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 30px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 1;
        }

        .resource-text {
            line-height: 20px;
            font-size: 11px;
        }

        #playerBuffs {
            position: absolute;
            top: 90px;
            left: 20px;
            display: flex;
            gap: 8px;
            pointer-events: none;
        }

        .buff-icon {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.65);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            position: relative;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .buff-icon.buff {
            border-color: rgba(76, 175, 80, 0.8);
        }

        .buff-icon.debuff {
            border-color: rgba(244, 67, 54, 0.8);
        }

        .buff-timer {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #abilities {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .ability {
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 30, 0.9);
            border: 3px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .ability:hover {
            border-color: #888;
            transform: scale(1.05);
        }

        .ability.on-cooldown {
            filter: brightness(0.3);
            cursor: not-allowed;
        }

        .ability-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .ability-name {
            font-size: 10px;
            text-align: center;
        }

        .ability-key {
            font-size: 10px;
            color: #aaa;
            position: absolute;
            top: 2px;
            left: 4px;
            font-weight: bold;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: yellow;
            font-size: 18px;
            font-weight: bold;
            border-radius: 5px;
        }

        #combatLog {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            color: #ccc;
        }

        .combat-message {
            margin: 2px 0;
            animation: fadeIn 0.3s;
        }

        .damage { color: #ff6b6b; }
        .heal { color: #4caf50; }
        .ability-use { color: #64b5f6; }
        .buff { color: #ffeb3b; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        #gameStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            display: none;
            text-align: center;
        }

        #overlayContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.65);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s ease, visibility 0.25s ease;
            pointer-events: none;
        }

        #overlayContainer.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        #overlayContainer .overlay-content {
            background: rgba(12, 12, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
            min-width: 320px;
        }

        #overlayContainer .overlay-title {
            font-size: 36px;
            margin-bottom: 10px;
            color: #f5f5f5;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.7);
        }

        #overlayContainer.victory .overlay-title {
            color: #44ff44;
        }

        #overlayContainer.defeat .overlay-title {
            color: #ff5555;
        }

        #overlayContainer.paused .overlay-title {
            color: #ffeb3b;
        }

        #overlayContainer .overlay-subtitle {
            font-size: 16px;
            color: #d0d4ff;
            margin-bottom: 24px;
            line-height: 1.4;
            white-space: pre-line;
        }

        .overlay-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .overlay-button {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: linear-gradient(135deg, #3f51b5, #5c6bc0);
            color: #fff;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
            transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
        }

        .overlay-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.5);
            filter: brightness(1.1);
        }

        .overlay-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .overlay-button.secondary {
            background: linear-gradient(135deg, #009688, #26a69a);
        }

        #controls {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }

        .control-item {
            margin: 5px 0;
        }

        #targetIndicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid #ff6b6b;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 10, 0.92);
            border: 1px solid #666;
            border-radius: 6px;
            padding: 8px;
            color: #fff;
            font-size: 11px;
            width: 180px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            display: none;
            text-align: left;
            z-index: 10;
        }

        .ability-tooltip-title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .ability-tooltip-cooldown {
            color: #64b5f6;
            margin-top: 6px;
        }

        .ability-tooltip-remaining {
            margin-top: 4px;
            color: #ffeb3b;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="playerHealth" class="health-bar-container">
            <div class="bar-text">Rogue: <span id="playerHpText">100/100</span></div>
            <div class="health-bar" style="width: 100%"></div>
        </div>
        
        <div id="playerEnergy" class="resource-bar-container">
            <div class="bar-text resource-text">Energy: <span id="playerEnergyText">100/100</span></div>
            <div class="energy-bar" style="width: 100%"></div>
        </div>

        <div id="comboPoints"></div>

        <div id="playerBuffs"></div>

        <div id="enemyHealth" class="health-bar-container">
            <div class="bar-text">Frost Mage: <span id="enemyHpText">100/100</span></div>
            <div class="health-bar" style="width: 100%"></div>
        </div>
        
        <div id="enemyMana" class="resource-bar-container">
            <div class="bar-text resource-text">Mana: <span id="enemyManaText">100/100</span></div>
            <div class="mana-bar" style="width: 100%"></div>
        </div>

        <div id="enemyCastBar">
            <div class="cast-progress"></div>
            <div class="cast-text">Ready</div>
        </div>
        
        <div id="targetIndicator">Target: Frost Mage</div>
        
        <div id="abilities"></div>
        
        <div id="combatLog"></div>

        <div id="controls">
            <div class="control-item"><strong>Movement:</strong> WASD</div>
            <div class="control-item"><strong>Camera:</strong> Mouse</div>
            <div class="control-item"><strong>Jump:</strong> Space</div>
            <div class="control-item"><strong>Abilities:</strong> 1-7</div>
            <div class="control-item"><strong>Target:</strong> Tab</div>
        </div>

        <div id="overlayContainer">
            <div class="overlay-content">
                <div class="overlay-title" id="overlayTitle">Game Paused</div>
                <div class="overlay-subtitle" id="overlaySubtitle">Press Escape to resume.</div>
                <div class="overlay-buttons">
                    <button type="button" id="resumeButton" class="overlay-button secondary">Resume Duel</button>
                    <button type="button" id="restartButton" class="overlay-button">Restart Duel</button>
                </div>
            </div>
        </div>

        <div id="gameStatus"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        const gameState = {
            player: {
                position: new THREE.Vector3(0, 1, 10),
                rotation: 0,
                velocity: new THREE.Vector3(0, 0, 0),
                health: 100,
                maxHealth: 100,
                energy: 100,
                maxEnergy: 100,
                comboPoints: 0,
                maxComboPoints: 5,
                isStealthed: false,
                isRooted: false,
                rootDuration: 0,
                buffs: new Map(),
                inCombat: false,
                abilities: [
                    {
                        name: 'Sinister Strike',
                        label: 'Sinister',
                        key: '1',
                        icon: 'âš”ï¸',
                        description: 'A vicious melee attack dealing moderate damage to the target.',
                        cost: 40,
                        damage: 25,
                        buildsCombo: true,
                        comboPointsGenerated: 1,
                        cooldown: 0,
                        maxCooldown: 0,
                        cooldownText: 'No cooldown'
                    },
                    {
                        name: 'Backstab',
                        label: 'Backstab',
                        key: '2',
                        icon: 'ðŸ—¡ï¸',
                        description: 'Strike from the shadows for massive damage when positioned behind the enemy.',
                        cost: 60,
                        damage: 50,
                        buildsCombo: true,
                        comboPointsGenerated: 1,
                        cooldown: 0,
                        maxCooldown: 4,
                        requiresStealth: false,
                        requiresBehind: true,
                        cooldownText: 'Cooldown: 4s'
                    },
                    {
                        name: 'Stealth',
                        label: 'Stealth',
                        key: '3',
                        icon: 'ðŸ‘¤',
                        description: 'Slip into the shadows for 10 seconds, allowing you to open with powerful attacks.',
                        cost: 0,
                        cooldown: 0,
                        maxCooldown: 10,
                        duration: 10,
                        cooldownText: 'Cooldown: 10s'
                    },
                    {
                        name: 'Sprint',
                        label: 'Sprint',
                        key: '4',
                        icon: 'ðŸ’¨',
                        description: 'Boost your movement speed dramatically for a short duration.',
                        cost: 0,
                        cooldown: 0,
                        maxCooldown: 60,
                        duration: 8,
                        cooldownText: 'Cooldown: 60s'
                    },
                    {
                        name: 'Evasion',
                        label: 'Evasion',
                        key: '5',
                        icon: 'ðŸŒ€',
                        description: 'Dodge incoming attacks, greatly increasing your chance to avoid damage.',
                        cost: 0,
                        cooldown: 0,
                        maxCooldown: 180,
                        duration: 5,
                        cooldownText: 'Cooldown: 180s'
                    },
                    {
                        name: 'Ambush',
                        label: 'Ambush',
                        key: '6',
                        icon: 'â˜ ï¸',
                        description: 'Open from stealth with a brutal strike that deals heavy damage.',
                        cost: 60,
                        damage: 70,
                        buildsCombo: true,
                        comboPointsGenerated: 2,
                        cooldown: 0,
                        maxCooldown: 0,
                        requiresStealth: true,
                        cooldownText: 'No cooldown'
                    },
                    {
                        name: 'Eviscerate',
                        label: 'Eviscerate',
                        key: '7',
                        icon: 'ðŸ’¥',
                        description: 'A brutal finishing move that consumes combo points for massive damage.',
                        cost: 35,
                        damage: 20,
                        damagePerCombo: 18,
                        finisher: true,
                        cooldown: 0,
                        maxCooldown: 0,
                        cooldownText: 'No cooldown'
                    }
                ]
            },
            enemies: [
                {
                    name: 'Frost Mage',
                    position: new THREE.Vector3(0, 1, -10),
                    rotation: 0,
                    velocity: new THREE.Vector3(0, 0, 0),
                    health: 100,
                    maxHealth: 100,
                    mana: 100,
                    maxMana: 100,
                    isCasting: false,
                    castTime: 0,
                    castDuration: 0,
                    castCost: 0,
                    currentCast: null,
                    isRooted: false,
                    rootDuration: 0,
                    abilities: [
                        { name: 'Frostbolt', cost: 30, damage: 35, castTime: 2.5, cooldown: 0 },
                        { name: 'Frost Nova', cost: 40, damage: 15, cooldown: 0, maxCooldown: 20, isInstant: true },
                        { name: 'Blink', cost: 20, cooldown: 0, maxCooldown: 15, isInstant: true },
                        { name: 'Ice Barrier', cost: 50, cooldown: 0, maxCooldown: 30, shield: 40, isInstant: true },
                        { name: 'Cone of Cold', cost: 35, damage: 25, cooldown: 0, maxCooldown: 8, isInstant: true }
                    ],
                    shield: 0,
                    aiState: 'aggressive',
                    lastAbilityTime: 0,
                    awareness: 1,
                    lastKnownPlayerPos: null,
                    detectCooldown: 0,
                    searchTimer: 0,
                    patrolAngle: 0
                }
            ],
            currentTarget: 0,
            camera: {
                pitch: 0,
                yaw: 0,
                distance: 15,
                targetDistance: 15,
                minDistance: 8,
                maxDistance: 25,
                zoomSpeed: 5,
                height: 5,
                targetHeight: 5,
                heightRatio: 5 / 15,
                defaultDistance: 15
            },
            input: {
                keys: {},
                mouseX: 0,
                mouseY: 0
            },
            gameOver: false,
            isPaused: false,
            outcome: null,
            overlayMessage: null,
            particles: []
        };

        const initialPlayerState = {
            position: gameState.player.position.clone(),
            rotation: gameState.player.rotation,
            health: gameState.player.maxHealth,
            maxHealth: gameState.player.maxHealth,
            energy: gameState.player.maxEnergy,
            maxEnergy: gameState.player.maxEnergy,
            comboPoints: 0,
            isStealthed: false,
            isRooted: false,
            rootDuration: 0,
            inCombat: false
        };

        const initialEnemyStates = gameState.enemies.map(enemy => ({
            position: enemy.position.clone(),
            rotation: enemy.rotation,
            maxHealth: enemy.maxHealth,
            maxMana: enemy.maxMana,
            aiState: enemy.aiState,
            awareness: enemy.awareness,
            detectCooldown: enemy.detectCooldown,
            searchTimer: enemy.searchTimer,
            patrolAngle: enemy.patrolAngle
        }));

        const initialCameraState = {
            pitch: gameState.camera.pitch,
            yaw: gameState.camera.yaw,
            distance: gameState.camera.distance,
            targetDistance: gameState.camera.targetDistance,
            minDistance: gameState.camera.minDistance,
            maxDistance: gameState.camera.maxDistance,
            zoomSpeed: gameState.camera.zoomSpeed,
            height: gameState.camera.height,
            targetHeight: gameState.camera.targetHeight,
            heightRatio: gameState.camera.heightRatio,
            defaultDistance: gameState.camera.defaultDistance
        };

        function getCurrentEnemy() {
            return gameState.enemies[gameState.currentTarget] || null;
        }

        function getEnemyName(enemy = getCurrentEnemy()) {
            return enemy?.name || 'Enemy';
        }

        function updateTargetIndicator() {
            const targetIndicator = document.getElementById('targetIndicator');
            if (!targetIndicator) return;

            const enemy = getCurrentEnemy();
            if (enemy && enemy.health > 0) {
                targetIndicator.textContent = `Target: ${getEnemyName(enemy)}`;
            } else {
                targetIndicator.textContent = 'No Target';
            }
        }

        function selectNextTarget() {
            if (gameState.enemies.length === 0) {
                updateTargetIndicator();
                return;
            }

            const previousEnemy = getCurrentEnemy();
            let nextIndex = gameState.currentTarget;
            for (let i = 0; i < gameState.enemies.length; i++) {
                nextIndex = (nextIndex + 1) % gameState.enemies.length;
                const potentialTarget = gameState.enemies[nextIndex];
                if (potentialTarget && potentialTarget.health > 0) {
                    if (previousEnemy && previousEnemy !== potentialTarget) {
                        interruptEnemyCast('Target Changed', previousEnemy);
                    }
                    gameState.currentTarget = nextIndex;
                    updateTargetIndicator();
                    return;
                }
            }

            if (previousEnemy && previousEnemy.health <= 0) {
                interruptEnemyCast('Target Changed', previousEnemy);
            }

            updateTargetIndicator();
        }

        function setPlayerBuff(name, { duration = 0, icon = '', type = 'buff' } = {}) {
            gameState.player.buffs.set(name, {
                duration,
                remaining: duration,
                icon,
                type
            });
        }

        function removePlayerBuff(name) {
            if (!gameState.player.buffs.has(name)) {
                return;
            }
            gameState.player.buffs.delete(name);
            if (name === 'stealth') {
                gameState.player.isStealthed = false;
                playerMaterial.opacity = 1;
                playerMaterial.transparent = false;
            }
        }

        const enemyCastBarUI = {
            container: document.getElementById('enemyCastBar'),
            progress: document.querySelector('#enemyCastBar .cast-progress'),
            text: document.querySelector('#enemyCastBar .cast-text'),
            hideTimeout: null
        };

        const activeTimeouts = new Set();

        function scheduleTimeout(callback, delay) {
            const timeoutId = setTimeout(() => {
                activeTimeouts.delete(timeoutId);
                callback();
            }, delay);
            activeTimeouts.add(timeoutId);
            return timeoutId;
        }

        function cancelTrackedTimeout(timeoutId) {
            if (!timeoutId && timeoutId !== 0) return;
            clearTimeout(timeoutId);
            activeTimeouts.delete(timeoutId);
        }

        function clearAllTrackedTimeouts() {
            activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            activeTimeouts.clear();
        }

        const overlayUI = {
            container: document.getElementById('overlayContainer'),
            title: document.getElementById('overlayTitle'),
            subtitle: document.getElementById('overlaySubtitle'),
            restartButton: document.getElementById('restartButton'),
            resumeButton: document.getElementById('resumeButton')
        };

        function setOverlayActive(active) {
            if (!overlayUI.container) return;
            if (active) {
                if (!overlayUI.container.classList.contains('active')) {
                    overlayUI.container.classList.add('active');
                }
                if (document.pointerLockElement === document.body) {
                    document.exitPointerLock();
                }
            } else {
                overlayUI.container.classList.remove('active');
            }
        }

        function updateOverlay(override) {
            if (!overlayUI.container) return;

            let state = override?.state || null;
            if (!state) {
                if (gameState.gameOver) {
                    state = gameState.outcome || 'defeat';
                } else if (gameState.isPaused) {
                    state = 'paused';
                }
            }

            if (!state) {
                overlayUI.container.classList.remove('victory', 'defeat', 'paused');
                if (overlayUI.subtitle) {
                    overlayUI.subtitle.textContent = '';
                }
                setOverlayActive(false);
                return;
            }

            overlayUI.container.classList.remove('victory', 'defeat', 'paused');
            overlayUI.container.classList.add(state);

            let title = override?.title;
            let subtitle = override?.subtitle;
            let showRestart = override?.showRestart;
            let showResume = override?.showResume;

            if (!override) {
                if (state === 'paused') {
                    title = 'Game Paused';
                    subtitle = 'Press Escape or click resume to continue.';
                    showRestart = true;
                    showResume = true;
                } else {
                    const message = gameState.overlayMessage;
                    if (message) {
                        title = message.title;
                        subtitle = message.subtitle;
                    } else if (state === 'victory') {
                        title = 'Victory!';
                        subtitle = 'All enemies defeated. Click restart to duel again.';
                    } else if (state === 'defeat') {
                        title = 'Defeat';
                        subtitle = 'You were defeated. Click restart to try again.';
                    }
                    showRestart = true;
                    showResume = false;
                }
            } else {
                if (typeof showRestart === 'undefined') {
                    showRestart = true;
                }
                if (typeof showResume === 'undefined') {
                    showResume = state === 'paused';
                }
            }

            if (overlayUI.title) {
                overlayUI.title.textContent = title || '';
            }
            if (overlayUI.subtitle) {
                overlayUI.subtitle.textContent = subtitle || '';
            }

            if (overlayUI.restartButton) {
                overlayUI.restartButton.style.display = showRestart ? 'block' : 'none';
            }
            if (overlayUI.resumeButton) {
                overlayUI.resumeButton.style.display = showResume ? 'block' : 'none';
            }

            setOverlayActive(true);
        }

        if (overlayUI.restartButton) {
            overlayUI.restartButton.addEventListener('click', (event) => {
                event.preventDefault();
                resetGameState();
            });
        }

        if (overlayUI.resumeButton) {
            overlayUI.resumeButton.addEventListener('click', (event) => {
                event.preventDefault();
                togglePause(false);
            });
        }

        function togglePause(forceState) {
            if (gameState.gameOver) {
                return;
            }

            const desiredState = typeof forceState === 'boolean' ? forceState : !gameState.isPaused;
            if (gameState.isPaused === desiredState) {
                updateOverlay();
                return;
            }

            gameState.isPaused = desiredState;

            if (gameState.isPaused) {
                gameState.input.keys = {};
            } else {
                lastTime = typeof performance !== 'undefined' ? performance.now() : Date.now();
            }

            updateUI();
        }
        function showEnemyCastBar(spellName, duration) {
            if (!enemyCastBarUI.container) return;
            if (enemyCastBarUI.hideTimeout) {
                cancelTrackedTimeout(enemyCastBarUI.hideTimeout);
                enemyCastBarUI.hideTimeout = null;
            }

            enemyCastBarUI.container.classList.add('active');
            enemyCastBarUI.container.classList.remove('interrupted');
            enemyCastBarUI.progress.style.width = '0%';

            const durationText = duration > 0 ? ` (${duration.toFixed(1)}s)` : '';
            enemyCastBarUI.text.textContent = `${spellName}${durationText}`;
        }

        function updateEnemyCastBarProgress(remainingTime) {
            if (!enemyCastBarUI.container) return;
            const enemy = getCurrentEnemy();
            if (!enemy) return;

            const duration = enemy.castDuration;
            if (duration <= 0) return;

            const clampedRemaining = Math.max(0, remainingTime);
            const percent = Math.min(1, Math.max(0, (duration - clampedRemaining) / duration));
            enemyCastBarUI.progress.style.width = `${(percent * 100).toFixed(2)}%`;

            const secondsText = clampedRemaining.toFixed(1);
            enemyCastBarUI.text.textContent = `${enemy.currentCast} (${secondsText}s)`;
        }

        function hideEnemyCastBar(interrupted = false, message = 'Interrupted') {
            if (!enemyCastBarUI.container) return;
            if (enemyCastBarUI.hideTimeout) {
                cancelTrackedTimeout(enemyCastBarUI.hideTimeout);
                enemyCastBarUI.hideTimeout = null;
            }

            if (interrupted) {
                enemyCastBarUI.container.classList.add('active');
                enemyCastBarUI.container.classList.add('interrupted');
                enemyCastBarUI.progress.style.width = '100%';
                enemyCastBarUI.text.textContent = message;

                enemyCastBarUI.hideTimeout = scheduleTimeout(() => {
                    enemyCastBarUI.container.classList.remove('active', 'interrupted');
                    enemyCastBarUI.progress.style.width = '0%';
                    enemyCastBarUI.text.textContent = 'Ready';
                    enemyCastBarUI.hideTimeout = null;
                }, 600);
            } else {
                enemyCastBarUI.container.classList.remove('active', 'interrupted');
                enemyCastBarUI.progress.style.width = '0%';
                enemyCastBarUI.text.textContent = 'Ready';
            }
        }

        function interruptEnemyCast(reason, enemyOverride = getCurrentEnemy()) {
            const enemy = enemyOverride;
            if (!enemy || !enemy.isCasting) return;

            const interruptedSpell = enemy.currentCast;
            enemy.isCasting = false;
            enemy.castTime = 0;
            enemy.castDuration = 0;
            enemy.castCost = 0;
            enemy.currentCast = null;

            const interruptionText = reason ? `Interrupted (${reason})` : 'Interrupted';
            hideEnemyCastBar(true, interruptionText);

            if (interruptedSpell) {
                const logReason = reason ? ` (${reason})` : '';
                addCombatMessage(`${getEnemyName(enemy)}'s ${interruptedSpell} was interrupted${logReason}!`, 'ability-use');
            }
        }

        function renderAbilities() {
            const abilitiesContainer = document.getElementById('abilities');
            const abilityHtml = gameState.player.abilities.map((ability, index) => `
                <div class="ability" data-ability="${index}">
                    <span class="ability-key">${ability.key || index + 1}</span>
                    <span class="ability-icon">${ability.icon}</span>
                    <span class="ability-name">${ability.label || ability.name}</span>
                    <div class="ability-tooltip">
                        <div class="ability-tooltip-title">${ability.name}</div>
                        <div>${ability.description}</div>
                        <div class="ability-tooltip-cooldown">${ability.cooldownText}</div>
                        <div class="ability-tooltip-remaining">Ready</div>
                    </div>
                </div>
            `).join('');
            abilitiesContainer.innerHTML = abilityHtml;
        }

        function initializeAbilityUI() {
            renderAbilities();

            const abilityElements = document.querySelectorAll('#abilities .ability');
            abilityElements.forEach(element => {
                element.addEventListener('mouseenter', () => {
                    const tooltip = element.querySelector('.ability-tooltip');
                    if (tooltip) {
                        tooltip.style.display = 'block';
                    }
                });

                element.addEventListener('mouseleave', () => {
                    const tooltip = element.querySelector('.ability-tooltip');
                    if (tooltip) {
                        tooltip.style.display = 'none';
                    }
                });
            });

            bindAbilityClickHandlers();
        }

        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000033, 10, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Arena floor
        const floorGeometry = new THREE.CircleGeometry(30, 32);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a3a,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Arena walls (pillars)
        const pillarGeometry = new THREE.CylinderGeometry(1, 1, 10, 8);
        const pillarMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a6a });
        
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.set(Math.cos(angle) * 25, 5, Math.sin(angle) * 25);
            pillar.castShadow = true;
            scene.add(pillar);
        }

        // Create player (Rogue)
        const playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // Create enemy (Frost Mage)
        const enemyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemyMesh.castShadow = true;
        scene.add(enemyMesh);

        // Particle system for effects
        class Particle {
            constructor(position, velocity, color, lifetime) {
                this.position = position.clone();
                this.velocity = velocity;
                this.color = color;
                this.lifetime = lifetime;
                this.maxLifetime = lifetime;
                
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update(deltaTime) {
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    scene.remove(this.mesh);
                    return false;
                }
                
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.mesh.position.copy(this.position);
                this.mesh.material.opacity = this.lifetime / this.maxLifetime;
                this.mesh.material.transparent = true;
                
                return true;
            }
        }

        function createParticleEffect(position, type) {
            const particleCount = type === 'frost' ? 20 : 15;
            for (let i = 0; i < particleCount; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                );
                const color = type === 'frost' ? 0x00bfff : 
                              type === 'damage' ? 0xff0000 : 
                              type === 'heal' ? 0x00ff00 : 0xffff00;
                gameState.particles.push(new Particle(position, velocity, color, 1));
            }
        }

        // Combat log
        function addCombatMessage(message, type) {
            const log = document.getElementById('combatLog');
            const messageDiv = document.createElement('div');
            messageDiv.className = `combat-message ${type}`;
            messageDiv.textContent = message;
            log.appendChild(messageDiv);
            log.scrollTop = log.scrollHeight;
            
            // Remove old messages
            while (log.children.length > 10) {
                log.removeChild(log.firstChild);
            }
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                if (!gameState.gameOver) {
                    togglePause();
                }
                return;
            }

            if (gameState.isPaused || gameState.gameOver) {
                return;
            }

            if (e.key === 'Tab') {
                e.preventDefault();
                selectNextTarget();
                return;
            }

            const key = e.key.toLowerCase();
            gameState.input.keys[key] = true;

            // Ability usage
            if (e.key >= '1' && e.key <= '9') {
                const abilityIndex = parseInt(e.key, 10) - 1;
                if (abilityIndex < gameState.player.abilities.length) {
                    usePlayerAbility(abilityIndex);
                }
            }
        });

        function bindAbilityClickHandlers() {
            const abilityElements = document.querySelectorAll('#abilities .ability');
            abilityElements.forEach(element => {
                element.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    const abilityIndex = parseInt(element.dataset.ability, 10);
                    if (!Number.isNaN(abilityIndex)) {
                        usePlayerAbility(abilityIndex);
                    }
                });
            });
        }

        document.addEventListener('keyup', (e) => {
            gameState.input.keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                gameState.camera.yaw -= e.movementX * 0.002;
                gameState.camera.pitch -= e.movementY * 0.002;
                gameState.camera.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, gameState.camera.pitch));
            }
        });

        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();

            const cameraState = gameState.camera;

            if (event.buttons === 4) {
                cameraState.targetDistance = THREE.MathUtils.clamp(
                    cameraState.defaultDistance,
                    cameraState.minDistance,
                    cameraState.maxDistance
                );
            } else {
                const zoomDelta = event.deltaY * 0.01;
                cameraState.targetDistance = THREE.MathUtils.clamp(
                    cameraState.targetDistance + zoomDelta,
                    cameraState.minDistance,
                    cameraState.maxDistance
                );
            }

            cameraState.targetHeight = cameraState.heightRatio * cameraState.targetDistance;
        }, { passive: false });

        document.addEventListener('click', (event) => {
            if (gameState.isPaused || gameState.gameOver) {
                return;
            }

            if (event.target.closest('.ability')) {
                return;
            }

            if (document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            }
        });

        // Ability system
        function usePlayerAbility(index) {
            if (gameState.gameOver || gameState.isPaused) return;

            const ability = gameState.player.abilities[index];
            if (!ability) return;

            const enemy = getCurrentEnemy();
            if (!enemy) {
                addCombatMessage('No target selected!', 'ability-use');
                return;
            }

            // Check cooldown
            if (ability.cooldown > 0) {
                addCombatMessage(`${ability.name} is on cooldown!`, 'ability-use');
                return;
            }
            
            // Check energy cost
            if (ability.cost > gameState.player.energy) {
                addCombatMessage('Not enough energy!', 'ability-use');
                return;
            }
            
            // Check special requirements
            if (ability.requiresStealth && !gameState.player.isStealthed) {
                addCombatMessage(`${ability.name} requires stealth!`, 'ability-use');
                return;
            }

            if (ability.requiresBehind) {
                const toEnemy = enemy.position.clone().sub(gameState.player.position).normalize();
                const enemyFacing = new THREE.Vector3(Math.sin(enemy.rotation), 0, Math.cos(enemy.rotation));
                const dotProduct = toEnemy.dot(enemyFacing);
                if (dotProduct < 0.5) {
                    addCombatMessage('Must be behind target!', 'ability-use');
                    return;
                }
            }

            const distance = gameState.player.position.distanceTo(enemy.position);

            // Execute ability
            switch (ability.name) {
                case 'Stealth':
                    if (distance < 10) {
                        addCombatMessage('Too close to enemy!', 'ability-use');
                        return;
                    }
                    gameState.player.isStealthed = true;
                    setPlayerBuff('stealth', {
                        duration: ability.duration,
                        icon: ability.icon,
                        type: 'buff'
                    });
                    playerMaterial.opacity = 0.3;
                    playerMaterial.transparent = true;
                    addCombatMessage('You vanish into the shadows!', 'buff');
                    break;

                case 'Sprint':
                    setPlayerBuff('sprint', {
                        duration: ability.duration,
                        icon: ability.icon,
                        type: 'buff'
                    });
                    addCombatMessage('Sprint activated!', 'buff');
                    break;

                case 'Evasion':
                    setPlayerBuff('evasion', {
                        duration: ability.duration,
                        icon: ability.icon,
                        type: 'buff'
                    });
                    addCombatMessage('Evasion activated!', 'buff');
                    break;
                    
                default:
                    // Damage abilities
                    if (distance > 5) {
                        addCombatMessage('Too far from target!', 'ability-use');
                        return;
                    }

                    const previousComboPoints = gameState.player.comboPoints || 0;
                    let damage = ability.damage || 0;
                    let comboPointsUsed = 0;

                    if (ability.finisher) {
                        comboPointsUsed = previousComboPoints;
                        const bonusPerPoint = ability.damagePerCombo || 0;
                        damage += comboPointsUsed * bonusPerPoint;
                    }

                    // Ambush and Backstab get bonus from stealth
                    if ((ability.name === 'Ambush' || ability.name === 'Backstab') && gameState.player.isStealthed) {
                        damage *= 1.5;
                    }

                    let damageDealt = damage;

                    if (enemy.shield > 0) {
                        const shieldDamage = Math.min(damageDealt, enemy.shield);
                        enemy.shield -= shieldDamage;
                        damageDealt -= shieldDamage;
                        if (enemy.shield <= 0) {
                            addCombatMessage('Ice Barrier broken!', 'damage');
                        }
                    }

                    damageDealt = Math.max(0, damageDealt);
                    enemy.health -= damageDealt;
                    createParticleEffect(enemy.position, 'damage');
                    if (ability.finisher && comboPointsUsed > 0) {
                        addCombatMessage(
                            `${ability.name} consumes ${comboPointsUsed} combo point${comboPointsUsed === 1 ? '' : 's'} for ${Math.round(damageDealt)} damage!`,
                            'damage'
                        );
                    } else {
                        addCombatMessage(`${ability.name} hits for ${Math.round(damageDealt)} damage!`, 'damage');
                    }

                    if (ability.finisher) {
                        if (gameState.player.comboPoints !== 0) {
                            gameState.player.comboPoints = 0;
                        }
                    } else if (ability.buildsCombo) {
                        const generated = ability.comboPointsGenerated ?? 1;
                        const newComboPoints = Math.min(
                            gameState.player.maxComboPoints,
                            previousComboPoints + generated
                        );
                        gameState.player.comboPoints = newComboPoints;
                    }

                    // Break stealth on damage
                    if (gameState.player.isStealthed) {
                        removePlayerBuff('stealth');
                    }
                    break;
            }
            
            // Consume energy and set cooldown
            gameState.player.energy -= ability.cost;
            if (ability.maxCooldown) {
                ability.cooldown = ability.maxCooldown;
            }

            updateUI();
        }

        // Enemy AI
        function updateEnemyAI(deltaTime) {
            const enemy = getCurrentEnemy();
            if (!enemy) {
                hideEnemyCastBar();
                return;
            }

            if (enemy.health <= 0) {
                enemy.velocity.set(0, 0, 0);
                interruptEnemyCast('Dead');
                return;
            }

            if (gameState.gameOver) {
                interruptEnemyCast('Combat Ended');
                return;
            }

            enemy.detectCooldown = Math.max(0, (enemy.detectCooldown || 0) - deltaTime);
            if (typeof enemy.awareness !== 'number') enemy.awareness = 0;
            if (typeof enemy.searchTimer !== 'number') enemy.searchTimer = 0;
            if (typeof enemy.patrolAngle !== 'number') enemy.patrolAngle = 0;

            const toPlayerVector = gameState.player.position.clone().sub(enemy.position);
            const distanceToPlayer = toPlayerVector.length();
            const directionToPlayer = distanceToPlayer > 0 ? toPlayerVector.clone().normalize() : new THREE.Vector3(0, 0, 0);

            let playerVisible = !gameState.player.isStealthed;
            if (gameState.player.isStealthed) {
                const forward = new THREE.Vector3(Math.sin(enemy.rotation), 0, Math.cos(enemy.rotation));
                const dot = forward.dot(directionToPlayer);
                const angle = directionToPlayer.lengthSq() === 0 ? Math.PI : Math.acos(THREE.MathUtils.clamp(dot, -1, 1));
                const withinView = angle < Math.PI / 3;
                const closeEnough = distanceToPlayer < 4;

                if (closeEnough) {
                    enemy.awareness = Math.min(1, enemy.awareness + deltaTime * 2);
                } else if (withinView && distanceToPlayer < 12) {
                    enemy.awareness = Math.min(1, enemy.awareness + deltaTime);
                } else {
                    enemy.awareness = Math.max(0, enemy.awareness - deltaTime * 0.5);
                }

                playerVisible = closeEnough || (withinView && enemy.awareness > 0.6);
                if (playerVisible) {
                    enemy.lastKnownPlayerPos = gameState.player.position.clone();
                }
            } else {
                enemy.awareness = 1;
                playerVisible = true;
                enemy.lastKnownPlayerPos = gameState.player.position.clone();
                enemy.searchTimer = 0;
                enemy.patrolAngle = 0;
            }

            let targetDirection = null;
            let targetDistance = Infinity;

            if (playerVisible) {
                targetDirection = directionToPlayer.clone();
                targetDistance = distanceToPlayer;
                enemy.aiState = 'aggressive';
                enemy.searchTimer = 0;
                enemy.patrolAngle = 0;
            } else if (enemy.lastKnownPlayerPos) {
                const toLastKnown = enemy.lastKnownPlayerPos.clone().sub(enemy.position);
                targetDistance = toLastKnown.length();
                targetDirection = targetDistance > 0 ? toLastKnown.normalize() : null;
                enemy.aiState = 'searching';
            } else {
                enemy.aiState = 'alert';
            }

            if (targetDirection) {
                enemy.rotation = Math.atan2(targetDirection.x, targetDirection.z);
            }

            // Root duration
            if (enemy.isRooted) {
                if (enemy.isCasting) {
                    interruptEnemyCast('Rooted');
                }
                enemy.rootDuration -= deltaTime;
                if (enemy.rootDuration <= 0) {
                    enemy.isRooted = false;
                }
            }

            // Handle casting
            if (enemy.isCasting) {
                if (enemy.castCost > 0 && enemy.mana < enemy.castCost) {
                    interruptEnemyCast('Out of Mana');
                    return;
                }

                enemy.castTime -= deltaTime;

                if (enemy.castDuration > 0) {
                    updateEnemyCastBarProgress(enemy.castTime);
                }

                if (enemy.castTime <= 0) {
                    completeCast();
                }
                return;
            }

            // Ability usage logic
            const now = Date.now() / 1000;
            if (now - enemy.lastAbilityTime > 1) { // AI thinks every second

                if (gameState.player.isStealthed) {
                    const coneOfCold = enemy.abilities[4];
                    if (playerVisible && coneOfCold && coneOfCold.cooldown <= 0 && enemy.detectCooldown <= 0 && enemy.mana >= (coneOfCold.cost || 0)) {
                        enemy.mana -= coneOfCold.cost || 0;
                        coneOfCold.cooldown = coneOfCold.maxCooldown || 0;
                        enemy.detectCooldown = 4;
                        createParticleEffect(enemy.position, 'frost');
                        addCombatMessage(`${getEnemyName(enemy)} sweeps the area with Cone of Cold, revealing you!`, 'ability-use');
                        removePlayerBuff('stealth');
                        gameState.player.isStealthed = false;
                        enemy.awareness = 1;
                        enemy.lastKnownPlayerPos = gameState.player.position.clone();
                    }
                } else {
                    // Ice Barrier when low health
                    if (enemy.health < 40 && enemy.abilities[3].cooldown <= 0 && enemy.mana >= 50) {
                        enemy.shield = 40;
                        enemy.mana -= 50;
                        enemy.abilities[3].cooldown = enemy.abilities[3].maxCooldown;
                        addCombatMessage(`${getEnemyName(enemy)} casts Ice Barrier!`, 'buff');
                        createParticleEffect(enemy.position, 'frost');
                    }
                    // Frost Nova when player is close
                    else if (playerVisible && distanceToPlayer < 5 && enemy.abilities[1].cooldown <= 0 && enemy.mana >= 40) {
                        gameState.player.velocity.set(0, 0, 0);
                        gameState.player.isRooted = true;
                        gameState.player.rootDuration = 3;
                        gameState.player.health -= 15;
                        enemy.mana -= 40;
                        enemy.abilities[1].cooldown = enemy.abilities[1].maxCooldown;
                        createParticleEffect(gameState.player.position, 'frost');
                        addCombatMessage(`${getEnemyName(enemy)} casts Frost Nova! You are frozen!`, 'damage');

                        // Blink away after nova
                        scheduleTimeout(() => {
                            if (enemy.abilities[2].cooldown <= 0 && enemy.mana >= 20) {
                                const blinkDirection = directionToPlayer.clone().multiplyScalar(-15);
                                enemy.position.add(blinkDirection);
                                enemy.mana -= 20;
                                enemy.abilities[2].cooldown = enemy.abilities[2].maxCooldown;
                                addCombatMessage(`${getEnemyName(enemy)} blinks away!`, 'ability-use');
                                createParticleEffect(enemy.position, 'frost');
                            }
                        }, 100);
                    }
                    // Cone of Cold at mid range
                    else if (playerVisible && distanceToPlayer < 8 && distanceToPlayer > 3 && enemy.abilities[4].cooldown <= 0 && enemy.mana >= 35) {
                        gameState.player.health -= 25;
                        enemy.mana -= 35;
                        enemy.abilities[4].cooldown = enemy.abilities[4].maxCooldown;
                        createParticleEffect(gameState.player.position, 'frost');
                        addCombatMessage(`${getEnemyName(enemy)} casts Cone of Cold for 25 damage!`, 'damage');
                    }
                    // Frostbolt as default
                    else if (playerVisible) {
                        const frostbolt = enemy.abilities[0];
                        if (frostbolt && enemy.mana >= (frostbolt.cost || 0) && frostbolt.castTime) {
                            enemy.isCasting = true;
                            enemy.castTime = frostbolt.castTime;
                            enemy.castDuration = frostbolt.castTime;
                            enemy.castCost = frostbolt.cost || 0;
                            enemy.currentCast = frostbolt.name;
                            showEnemyCastBar(frostbolt.name, frostbolt.castTime);
                            addCombatMessage(`${getEnemyName(enemy)} begins casting ${frostbolt.name}...`, 'ability-use');
                        }
                    }
                }

                enemy.lastAbilityTime = now;
            }

            // Movement
            if (!enemy.isRooted && !enemy.isCasting) {
                if (playerVisible && targetDirection) {
                    if (distanceToPlayer > 20) {
                        enemy.velocity = targetDirection.clone().multiplyScalar(3);
                    } else if (distanceToPlayer < 8) {
                        enemy.velocity = targetDirection.clone().multiplyScalar(-2);
                    } else {
                        const strafe = new THREE.Vector3(-targetDirection.z, 0, targetDirection.x);
                        enemy.velocity = strafe.multiplyScalar(Math.sin(now * 2) * 2);
                    }
                } else if (!playerVisible && enemy.lastKnownPlayerPos && targetDirection) {
                    if (targetDistance > 1.5) {
                        enemy.velocity = targetDirection.clone().multiplyScalar(2.5);
                    } else {
                        enemy.searchTimer += deltaTime;
                        enemy.patrolAngle += deltaTime * 1.5;
                        const patrolOffset = new THREE.Vector3(Math.cos(enemy.patrolAngle), 0, Math.sin(enemy.patrolAngle)).multiplyScalar(2);
                        const patrolTarget = enemy.lastKnownPlayerPos.clone().add(patrolOffset);
                        const toPatrol = patrolTarget.sub(enemy.position);
                        if (toPatrol.lengthSq() > 0.01) {
                            enemy.velocity = toPatrol.normalize().multiplyScalar(1.5);
                            enemy.rotation = Math.atan2(enemy.velocity.x, enemy.velocity.z);
                        } else {
                            enemy.velocity.set(0, 0, 0);
                        }

                        if (enemy.searchTimer > 6) {
                            enemy.lastKnownPlayerPos = null;
                            enemy.searchTimer = 0;
                            enemy.patrolAngle = 0;
                        }
                    }
                } else {
                    enemy.velocity.multiplyScalar(0.8);
                }
            } else {
                enemy.velocity.set(0, 0, 0);
            }
        }

        function completeCast() {
            const enemy = getCurrentEnemy();
            if (!enemy) return;

            const finishedSpell = enemy.currentCast;
            const castCost = enemy.castCost || 0;
            enemy.isCasting = false;

            if (finishedSpell === 'Frostbolt') {
                // Check if player evaded
                if (gameState.player.buffs.has('evasion')) {
                    addCombatMessage('Frostbolt missed! (Evasion)', 'buff');
                } else {
                    const damage = 35;
                    gameState.player.health -= damage;
                    const manaCost = castCost > 0 ? castCost : 30;
                    enemy.mana = Math.max(0, enemy.mana - manaCost);
                    createParticleEffect(gameState.player.position, 'frost');
                    addCombatMessage(`Frostbolt hits for ${damage} damage!`, 'damage');

                    // Slow effect
                    setPlayerBuff('slow', {
                        duration: 3,
                        icon: 'â„ï¸',
                        type: 'debuff'
                    });
                }
            }

            enemy.castTime = 0;
            enemy.castDuration = 0;
            enemy.castCost = 0;
            enemy.currentCast = null;
            hideEnemyCastBar();
        }

        // Update functions
        function updatePlayer(deltaTime) {
            const keys = gameState.input.keys;
            const hasSprint = gameState.player.buffs.has('sprint');
            const hasSlow = gameState.player.buffs.has('slow');
            const moveSpeed = hasSprint ? 15 : (hasSlow ? 5 : 8);
            
            // Movement
            if (gameState.player.isRooted) {
                gameState.player.velocity.x = 0;
                gameState.player.velocity.z = 0;
                gameState.player.rootDuration -= deltaTime;
                if (gameState.player.rootDuration <= 0) {
                    gameState.player.isRooted = false;
                    gameState.player.rootDuration = 0;
                }
            } else {
                let moveX = 0, moveZ = 0;
                if (keys['w']) moveZ = -1;
                if (keys['s']) moveZ = 1;
                if (keys['a']) moveX = -1;
                if (keys['d']) moveX = 1;

                if (moveX !== 0 || moveZ !== 0) {
                    const moveDir = new THREE.Vector3(moveX, 0, moveZ).normalize();

                    // Rotate movement based on camera yaw
                    const rotatedX = moveDir.x * Math.cos(gameState.camera.yaw) - moveDir.z * Math.sin(gameState.camera.yaw);
                    const rotatedZ = moveDir.x * Math.sin(gameState.camera.yaw) + moveDir.z * Math.cos(gameState.camera.yaw);

                    gameState.player.velocity.x = rotatedX * moveSpeed;
                    gameState.player.velocity.z = rotatedZ * moveSpeed;

                    // Break stealth on movement
                    if (gameState.player.isStealthed && (Math.abs(moveX) > 0 || Math.abs(moveZ) > 0)) {
                        // Allow some movement in stealth but slower
                        gameState.player.velocity.multiplyScalar(0.5);
                    }
                } else {
                    gameState.player.velocity.x *= 0.8;
                    gameState.player.velocity.z *= 0.8;
                }
            }
            
            // Jump
            if (keys[' '] && Math.abs(gameState.player.velocity.y) < 0.1) {
                gameState.player.velocity.y = 8;
            }
            
            // Apply gravity
            gameState.player.velocity.y -= 20 * deltaTime;
            
            // Update position
            gameState.player.position.add(gameState.player.velocity.clone().multiplyScalar(deltaTime));
            
            // Ground collision
            if (gameState.player.position.y < 1) {
                gameState.player.position.y = 1;
                gameState.player.velocity.y = 0;
            }
            
            // Arena bounds
            const distFromCenter = Math.sqrt(gameState.player.position.x ** 2 + gameState.player.position.z ** 2);
            if (distFromCenter > 28) {
                const dir = new THREE.Vector3(gameState.player.position.x, 0, gameState.player.position.z).normalize();
                gameState.player.position.x = dir.x * 28;
                gameState.player.position.z = dir.z * 28;
            }
            
            // Update mesh
            playerMesh.position.copy(gameState.player.position);
            
            // Energy regeneration
            gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + 20 * deltaTime);
            
            // Update buffs
            for (const [buffName, buffData] of gameState.player.buffs.entries()) {
                buffData.remaining -= deltaTime;
                if (buffData.remaining <= 0) {
                    removePlayerBuff(buffName);
                }
            }
            
            // Update ability cooldowns
            gameState.player.abilities.forEach(ability => {
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime;
                    if (ability.cooldown < 0) ability.cooldown = 0;
                }
            });
        }

        function updateEnemy(deltaTime) {
            const enemy = getCurrentEnemy();
            if (!enemy) {
                enemyMesh.visible = false;
                return;
            }

            // Update position
            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime));

            // Arena bounds
            const distFromCenter = Math.sqrt(enemy.position.x ** 2 + enemy.position.z ** 2);
            if (distFromCenter > 28) {
                const dir = new THREE.Vector3(enemy.position.x, 0, enemy.position.z).normalize();
                enemy.position.x = dir.x * 28;
                enemy.position.z = dir.z * 28;
            }

            // Update mesh
            enemyMesh.visible = true;
            enemyMesh.position.copy(enemy.position);
            enemyMesh.rotation.y = enemy.rotation;

            // Mana regeneration
            enemy.mana = Math.min(enemy.maxMana, enemy.mana + 10 * deltaTime);

            // Update ability cooldowns
            enemy.abilities.forEach(ability => {
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime;
                    if (ability.cooldown < 0) ability.cooldown = 0;
                }
            });
        }

        function updateCamera(deltaTime) {
            // Third-person camera
            const cameraState = gameState.camera;
            const lerpFactor = 1 - Math.exp(-cameraState.zoomSpeed * deltaTime);

            cameraState.distance = THREE.MathUtils.lerp(
                cameraState.distance,
                cameraState.targetDistance,
                lerpFactor
            );

            cameraState.targetHeight = cameraState.heightRatio * cameraState.targetDistance;
            const desiredHeight = cameraState.targetHeight;
            cameraState.height = THREE.MathUtils.lerp(
                cameraState.height,
                desiredHeight,
                lerpFactor
            );

            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraState.yaw) * cameraState.distance,
                cameraState.height + Math.sin(cameraState.pitch) * 10,
                Math.cos(cameraState.yaw) * cameraState.distance
            );

            camera.position.copy(gameState.player.position).add(cameraOffset);
            camera.lookAt(gameState.player.position.clone().add(new THREE.Vector3(0, 2, 0)));
        }

        function resetGameState() {
            clearAllTrackedTimeouts();
            hideEnemyCastBar();
            enemyCastBarUI.hideTimeout = null;

            gameState.gameOver = false;
            gameState.isPaused = false;
            gameState.outcome = null;
            gameState.overlayMessage = null;

            gameState.player.position.copy(initialPlayerState.position);
            gameState.player.rotation = initialPlayerState.rotation;
            gameState.player.velocity.set(0, 0, 0);
            gameState.player.maxHealth = initialPlayerState.maxHealth;
            gameState.player.health = initialPlayerState.maxHealth;
            gameState.player.maxEnergy = initialPlayerState.maxEnergy;
            gameState.player.energy = initialPlayerState.maxEnergy;
            gameState.player.comboPoints = initialPlayerState.comboPoints;
            gameState.player.isStealthed = initialPlayerState.isStealthed;
            gameState.player.isRooted = initialPlayerState.isRooted;
            gameState.player.rootDuration = initialPlayerState.rootDuration;
            gameState.player.inCombat = initialPlayerState.inCombat;
            gameState.player.buffs = new Map();

            gameState.player.abilities.forEach(ability => {
                ability.cooldown = 0;
            });

            playerMaterial.opacity = 1;
            playerMaterial.transparent = false;

            playerMesh.position.copy(gameState.player.position);
            playerMesh.rotation.y = gameState.player.rotation;

            const comboContainer = document.getElementById('comboPoints');
            if (comboContainer) {
                comboContainer.classList.remove('combo-change');
                if (comboContainer._comboTimeout) {
                    cancelTrackedTimeout(comboContainer._comboTimeout);
                    comboContainer._comboTimeout = null;
                }
                delete comboContainer.dataset.points;
                comboContainer.innerHTML = '';
            }

            gameState.enemies.forEach((enemy, index) => {
                const initialEnemy = initialEnemyStates[index];
                if (!initialEnemy) return;

                enemy.position.copy(initialEnemy.position);
                enemy.rotation = initialEnemy.rotation;
                if (enemy.velocity) {
                    enemy.velocity.set(0, 0, 0);
                } else {
                    enemy.velocity = new THREE.Vector3(0, 0, 0);
                }
                enemy.health = initialEnemy.maxHealth;
                enemy.maxHealth = initialEnemy.maxHealth;
                enemy.mana = initialEnemy.maxMana;
                enemy.maxMana = initialEnemy.maxMana;
                enemy.shield = 0;
                enemy.isCasting = false;
                enemy.castTime = 0;
                enemy.castDuration = 0;
                enemy.castCost = 0;
                enemy.currentCast = null;
                enemy.isRooted = false;
                enemy.rootDuration = 0;
                enemy.aiState = initialEnemy.aiState;
                enemy.awareness = initialEnemy.awareness;
                enemy.detectCooldown = initialEnemy.detectCooldown;
                enemy.searchTimer = initialEnemy.searchTimer;
                enemy.patrolAngle = initialEnemy.patrolAngle;
                enemy.lastAbilityTime = 0;
                enemy.lastKnownPlayerPos = null;
                enemy.abilities.forEach(ability => {
                    ability.cooldown = 0;
                });
            });

            if (gameState.enemies.length > 0) {
                const firstEnemy = gameState.enemies[0];
                enemyMesh.visible = true;
                enemyMesh.position.copy(firstEnemy.position);
                enemyMesh.rotation.y = firstEnemy.rotation;
            }

            gameState.currentTarget = 0;
            updateTargetIndicator();

            if (gameState.particles.length) {
                gameState.particles.forEach(particle => {
                    if (particle?.mesh) {
                        scene.remove(particle.mesh);
                    }
                });
                gameState.particles = [];
            }

            gameState.input.keys = {};

            const combatLog = document.getElementById('combatLog');
            if (combatLog) {
                combatLog.innerHTML = '';
            }

            const status = document.getElementById('gameStatus');
            if (status) {
                status.style.display = 'none';
                status.textContent = '';
            }

            Object.assign(gameState.camera, {
                pitch: initialCameraState.pitch,
                yaw: initialCameraState.yaw,
                distance: initialCameraState.distance,
                targetDistance: initialCameraState.targetDistance,
                minDistance: initialCameraState.minDistance,
                maxDistance: initialCameraState.maxDistance,
                zoomSpeed: initialCameraState.zoomSpeed,
                height: initialCameraState.height,
                targetHeight: initialCameraState.targetHeight,
                heightRatio: initialCameraState.heightRatio,
                defaultDistance: initialCameraState.defaultDistance
            });

            gameState.camera.targetHeight = gameState.camera.heightRatio * gameState.camera.targetDistance;

            lastTime = typeof performance !== 'undefined' ? performance.now() : Date.now();

            updateCamera(0.016);

            addCombatMessage('Duel begins!', 'buff');
            addCombatMessage('Click to capture mouse', 'ability-use');

            updateUI();
        }

        function updateUI() {
            // Player health
            const playerHealthBar = document.querySelector('#playerHealth .health-bar');
            const playerHealthPercent = Math.max(0, gameState.player.health / gameState.player.maxHealth * 100);
            playerHealthBar.style.width = playerHealthPercent + '%';
            document.getElementById('playerHpText').textContent =
                `${Math.max(0, Math.round(gameState.player.health))}/${gameState.player.maxHealth}`;

            // Player energy
            const playerEnergyBar = document.querySelector('#playerEnergy .energy-bar');
            const playerEnergyPercent = gameState.player.energy / gameState.player.maxEnergy * 100;
            playerEnergyBar.style.width = playerEnergyPercent + '%';
            document.getElementById('playerEnergyText').textContent =
                `${Math.round(gameState.player.energy)}/${gameState.player.maxEnergy}`;

            // Combo points
            const comboContainer = document.getElementById('comboPoints');
            if (comboContainer) {
                const maxPoints = gameState.player.maxComboPoints || 0;
                const currentPoints = Math.min(Math.max(0, gameState.player.comboPoints || 0), maxPoints);
                if (comboContainer.childElementCount !== maxPoints) {
                    comboContainer.innerHTML = '';
                    for (let i = 0; i < maxPoints; i++) {
                        const pip = document.createElement('div');
                        pip.className = 'combo-point';
                        comboContainer.appendChild(pip);
                    }
                }

                const pips = comboContainer.querySelectorAll('.combo-point');
                pips.forEach((pip, index) => {
                    if (index < currentPoints) {
                        pip.classList.add('active');
                    } else {
                        pip.classList.remove('active');
                    }
                });

                comboContainer.style.display = maxPoints > 0 ? 'flex' : 'none';

                const previousPoints = comboContainer.dataset.points;
                const currentPointsStr = String(currentPoints);
                if (previousPoints !== currentPointsStr) {
                    comboContainer.dataset.points = currentPointsStr;
                    comboContainer.classList.remove('combo-change');
                    void comboContainer.offsetWidth;
                    comboContainer.classList.add('combo-change');
                    if (comboContainer._comboTimeout) {
                        cancelTrackedTimeout(comboContainer._comboTimeout);
                        comboContainer._comboTimeout = null;
                    }
                    comboContainer._comboTimeout = scheduleTimeout(() => {
                        comboContainer.classList.remove('combo-change');
                        comboContainer._comboTimeout = null;
                    }, 250);
                }
            }

            // Enemy health
            const enemyHealthBar = document.querySelector('#enemyHealth .health-bar');
            const enemy = getCurrentEnemy();
            const enemyHealthPercent = enemy ? Math.max(0, enemy.health / enemy.maxHealth * 100) : 0;
            enemyHealthBar.style.width = enemyHealthPercent + '%';
            document.getElementById('enemyHpText').textContent = enemy
                ? `${Math.max(0, Math.round(enemy.health))}/${enemy.maxHealth}`
                : '0/0';

            // Enemy mana
            const enemyManaBar = document.querySelector('#enemyMana .mana-bar');
            const enemyManaPercent = enemy ? enemy.mana / enemy.maxMana * 100 : 0;
            enemyManaBar.style.width = enemyManaPercent + '%';
            document.getElementById('enemyManaText').textContent = enemy
                ? `${Math.round(enemy.mana)}/${enemy.maxMana}`
                : '0/0';

            updateTargetIndicator();

            // Player buffs
            const buffContainer = document.getElementById('playerBuffs');
            if (buffContainer) {
                buffContainer.innerHTML = '';
                gameState.player.buffs.forEach((buffData, buffName) => {
                    const buffElement = document.createElement('div');
                    const buffTypeClass = buffData.type === 'debuff' ? 'debuff' : 'buff';
                    buffElement.className = `buff-icon ${buffTypeClass}`;
                    buffElement.textContent = buffData.icon || 'â˜…';
                    buffElement.title = buffName.charAt(0).toUpperCase() + buffName.slice(1);

                    const timer = document.createElement('div');
                    timer.className = 'buff-timer';
                    const remaining = Math.max(0, buffData.remaining);
                    timer.textContent = Math.ceil(remaining).toString();
                    buffElement.appendChild(timer);

                    buffContainer.appendChild(buffElement);
                });
            }

            // Update ability cooldowns
            const abilityElements = document.querySelectorAll('.ability');
            abilityElements.forEach((element, index) => {
                const ability = gameState.player.abilities[index];
                if (!ability) return;

                const tooltip = element.querySelector('.ability-tooltip');
                if (tooltip) {
                    const remaining = tooltip.querySelector('.ability-tooltip-remaining');
                    if (remaining) {
                        remaining.textContent = ability.cooldown > 0
                            ? `Remaining cooldown: ${ability.cooldown.toFixed(1)}s`
                            : 'Ready';
                    }
                }

                // Remove old cooldown overlay
                const oldOverlay = element.querySelector('.cooldown-overlay');
                if (oldOverlay) oldOverlay.remove();

                if (ability.cooldown > 0) {
                    element.classList.add('on-cooldown');
                    const overlay = document.createElement('div');
                    overlay.className = 'cooldown-overlay';
                    overlay.textContent = Math.ceil(ability.cooldown);
                    element.appendChild(overlay);
                } else {
                    element.classList.remove('on-cooldown');
                }
            });
            
            const status = document.getElementById('gameStatus');
            if (status) {
                status.style.display = 'none';
                status.textContent = '';
            }

            if (gameState.player.health <= 0 && !gameState.gameOver) {
                gameState.gameOver = true;
                gameState.outcome = 'defeat';
                gameState.overlayMessage = {
                    title: 'Defeat',
                    subtitle: 'You were defeated. Click restart to try again.'
                };
                gameState.input.keys = {};
                gameState.player.velocity.set(0, 0, 0);
                gameState.enemies.forEach(enemyState => {
                    if (enemyState.velocity) {
                        enemyState.velocity.set(0, 0, 0);
                    }
                });
                interruptEnemyCast('Combat Ended');
                hideEnemyCastBar();
            } else if (!gameState.gameOver) {
                const allEnemiesDefeated = gameState.enemies.length > 0 &&
                    gameState.enemies.every(enemyState => enemyState.health <= 0);

                if (allEnemiesDefeated) {
                    gameState.gameOver = true;
                    gameState.outcome = 'victory';
                    gameState.overlayMessage = {
                        title: 'Victory!',
                        subtitle: 'All enemies defeated. Click restart to duel again.'
                    };
                    gameState.input.keys = {};
                    gameState.player.velocity.set(0, 0, 0);
                    gameState.enemies.forEach(enemyState => {
                        if (enemyState.velocity) {
                            enemyState.velocity.set(0, 0, 0);
                        }
                    });
                    interruptEnemyCast('Combat Ended');
                    hideEnemyCastBar();
                } else {
                    gameState.overlayMessage = null;
                    gameState.outcome = null;
                }
            }

            updateOverlay();
        }

        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (!gameState.isPaused) {
                if (!gameState.gameOver) {
                    updatePlayer(deltaTime);
                    updateEnemy(deltaTime);
                    updateEnemyAI(deltaTime);
                }

                // Update particles
                gameState.particles = gameState.particles.filter(particle => particle.update(deltaTime));

                updateCamera(deltaTime);
            }

            updateUI();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI initialization
        initializeAbilityUI();
        updateTargetIndicator();

        // Start messages
        addCombatMessage('Duel begins!', 'buff');
        addCombatMessage('Click to capture mouse', 'ability-use');

        // Start game
        animate(0);
    </script>
</body>
</html>
